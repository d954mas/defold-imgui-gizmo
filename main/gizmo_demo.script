local IMGUI = require "main.imgui"

local ACTION_TOUCH = hash("touch")
local DEG2RAD = math.pi / 180
local HASH_DRAW_LINE = hash("draw_line")

local function make_trs(position, scale)
    local m = vmath.matrix4()
    m.c0 = vmath.vector4(scale.x, 0, 0, 0)
    m.c1 = vmath.vector4(0, scale.y, 0, 0)
    m.c2 = vmath.vector4(0, 0, scale.z, 0)
    m.c3 = vmath.vector4(position.x, position.y, position.z, 1)
    return m
end

local function screen_to_world_ray(x, y, width, height, view, projection)
    local ndc_x = (2 * x / width) - 1
    local ndc_y = (2 * y / height) - 1
    local inv_vp = vmath.inv(projection * view)

    local near4 = inv_vp * vmath.vector4(ndc_x, ndc_y, -1, 1)
    local far4 = inv_vp * vmath.vector4(ndc_x, ndc_y, 1, 1)

    local near_inv_w = 1 / near4.w
    local far_inv_w = 1 / far4.w

    local near = vmath.vector3(near4.x * near_inv_w, near4.y * near_inv_w, near4.z * near_inv_w)
    local far = vmath.vector3(far4.x * far_inv_w, far4.y * far_inv_w, far4.z * far_inv_w)
    local dir = vmath.normalize(far - near)
    return near, dir
end

local function apply_matrix_to_go(id, matrix)
    local translation, rotation, scale = imgui_gizmo.decompose_matrix(matrix)
    go.set_position(translation, id)
    go.set_scale(scale, id)
    local q = imgui_gizmo.quat_from_euler(rotation)
    go.set_rotation(q, id)
end

local function set_tint(id, color)
    pcall(go.set, id, "tint", color)
end

local function draw_line(from, to, color)
    msg.post("@render:", HASH_DRAW_LINE, {
        start_point = from,
        end_point = to,
        color = color
    })
end

local function make_basis_matrix(right, up, forward, position)
    local m = vmath.matrix4()
    m.c0 = vmath.vector4(right.x, right.y, right.z, 0)
    m.c1 = vmath.vector4(up.x, up.y, up.z, 0)
    m.c2 = vmath.vector4(forward.x, forward.y, forward.z, 0)
    m.c3 = vmath.vector4(position.x, position.y, position.z, 1)
    return m
end

function init(self)
    IMGUI.init()
    imgui_gizmo.set_context()
    msg.post(".", "acquire_input_focus")
    msg.post("@render:", "use_camera_projection")
    msg.post("/camera#camera", "acquire_camera_focus")
    msg.post("@system:", "toggle_physics_debug") -- <3>
    self.view = vmath.matrix4()
    self.projection = vmath.matrix4()
    self.display_width, self.display_height = window.get_size()
    self.camera = msg.url("/camera#camera")
    self.camera_go = msg.url("/camera")

    self.sphere_id = go.get_id("sphere")
    self.cube_id = go.get_id("cube")

    self.objects = {
        sphere = {
            id = self.sphere_id,
            radius = 0.5,
            matrix = make_trs(go.get_position(self.sphere_id), vmath.vector3(1, 1, 1)),
        },
        cube = {
            id = self.cube_id,
            half_extents = vmath.vector3(0.5, 0.5, 0.5),
            matrix = make_trs(go.get_position(self.cube_id), vmath.vector3(1, 1, 1)),
        }
    }

    self.selected = nil
    self.last_selected = nil

    self.gizmo_operation = imgui_gizmo.OPERATION_TRANSLATE
    self.gizmo_mode = imgui_gizmo.MODE_LOCAL
    self.use_snap = false
    self.snap = vmath.vector3(1, 1, 1)

    self.draw_line_time = 0
    self.draw_line_from = vmath.vector3()
    self.draw_line_to = vmath.vector3()
    self.draw_line_color = vmath.vector4(1, 0, 0, 1)
end

function on_input(self, action_id, action)
    IMGUI.on_input(action_id, action)
    if IMGUI.is_imgui_handled_input() then
        return
    end
    if action_id == ACTION_TOUCH and action.pressed then
        local origin, dir = screen_to_world_ray(action.screen_x, action.screen_y, self.display_width, self.display_height, self.view, self.projection)
        local to = origin + dir * 1000
        local result = physics.raycast(origin, to, { hash("obstacle") })
        self.draw_line_from = origin
        self.draw_line_to = to
        self.draw_line_time = 0
        self.selected = nil
        if result then
            local hit_id = result.id
            if hit_id == self.objects.sphere.id then
                self.selected = "sphere"
            elseif hit_id == self.objects.cube.id then
                self.selected = "cube"
            end
        end
    end
end

function update(self, dt)
    self.view = camera.get_view(self.camera)
    self.projection = camera.get_projection(self.camera)
    self.display_width, self.display_height = window.get_size()

    IMGUI.on_resize(self.display_width, self.display_height)
    imgui.get_frame_height() -- NEED ANY IMGUI CALL SO DEFOLD IMGUI EXTENSION CREATE A FRAME
    imgui_gizmo.set_rect(0, 0, self.display_width, self.display_height)
    imgui_gizmo.set_drawlist_background()
    do
        local grid_size = 10
        local identity = vmath.matrix4()
        imgui_gizmo.draw_grid(self.view, self.projection, identity, grid_size)

        local right = vmath.vector3(0, 1, 0)
        local up = vmath.vector3(0, 0, 1)
        local forward = vmath.vector3(1, 0, 0)
        local vertical = make_basis_matrix(right, up, forward, vmath.vector3(0, 0, 0))
        imgui_gizmo.draw_grid(self.view, self.projection, vertical, grid_size)
    end
    imgui_gizmo.set_drawlist_foreground()
    if self.draw_line_time > 0 then
        self.draw_line_time = self.draw_line_time - dt
        draw_line(self.draw_line_from, self.draw_line_to, self.draw_line_color)
    end

    if self.selected then
        imgui.set_next_window_pos(12, 12)
        imgui.set_next_window_size(300, 190)
        local visible = imgui.begin_window("Matrix Inspector", false)
        if visible then
            imgui.text("Matrix Inspector")
            imgui.separator()

            local changed
            changed = imgui.radio_button("Translate", self.gizmo_operation == imgui_gizmo.OPERATION_TRANSLATE)
            if changed then self.gizmo_operation = imgui_gizmo.OPERATION_TRANSLATE end
            imgui.same_line()
            changed = imgui.radio_button("Rotate", self.gizmo_operation == imgui_gizmo.OPERATION_ROTATE)
            if changed then self.gizmo_operation = imgui_gizmo.OPERATION_ROTATE end
            imgui.same_line()
            changed = imgui.radio_button("Scale", self.gizmo_operation == imgui_gizmo.OPERATION_SCALE)
            if changed then self.gizmo_operation = imgui_gizmo.OPERATION_SCALE end

            local obj = self.objects[self.selected]
            local tr, rt, sc = imgui_gizmo.decompose_matrix(obj.matrix)
            local tr_changed, trx, try, trz = imgui.input_float3("Tr", tr.x, tr.y, tr.z)
            if tr_changed then
                tr = vmath.vector3(trx, try, trz)
            end
            local rt_changed, rtx, rty, rtz = imgui.input_float3("Rt", rt.x, rt.y, rt.z)
            if rt_changed then
                rt = vmath.vector3(rtx, rty, rtz)
            end
            local sc_changed, scx, scy, scz = imgui.input_float3("Sc", sc.x, sc.y, sc.z)
            if sc_changed then
                sc = vmath.vector3(scx, scy, scz)
            end
            if tr_changed or rt_changed or sc_changed then
                obj.matrix = imgui_gizmo.recompose_matrix(tr, rt, sc)
                apply_matrix_to_go(obj.id, obj.matrix)
            end

            changed = imgui.radio_button("Local", self.gizmo_mode == imgui_gizmo.MODE_LOCAL)
            if changed then self.gizmo_mode = imgui_gizmo.MODE_LOCAL end
            imgui.same_line()
            changed = imgui.radio_button("World", self.gizmo_mode == imgui_gizmo.MODE_WORLD)
            if changed then self.gizmo_mode = imgui_gizmo.MODE_WORLD end

            local snap_changed, snap_enabled = imgui.checkbox("Snap", self.use_snap)
            if snap_changed then
                self.use_snap = snap_enabled
            end
            imgui.same_line()
            local snap_vec_changed, sx, sy, sz = imgui.input_float3("##snap", self.snap.x, self.snap.y, self.snap.z)
            if snap_vec_changed then
                self.snap = vmath.vector3(sx, sy, sz)
            end
        end
        imgui.end_window()
    end

    if self.selected ~= self.last_selected then
        if self.last_selected == "sphere" then
            set_tint(self.objects.sphere.id, vmath.vector4(1, 1, 1, 1))
        elseif self.last_selected == "cube" then
            set_tint(self.objects.cube.id, vmath.vector4(1, 1, 1, 1))
        end
        if self.selected == "sphere" then
            set_tint(self.objects.sphere.id, vmath.vector4(1, 0.6, 0.2, 1))
        elseif self.selected == "cube" then
            set_tint(self.objects.cube.id, vmath.vector4(0.2, 0.8, 1, 1))
        end
        self.last_selected = self.selected
    end

    if self.selected then
        local operation = self.gizmo_operation
        if self.selected == "sphere" and operation == imgui_gizmo.OPERATION_SCALE then
            operation = imgui_gizmo.OPERATION_SCALEU
        end

        if self.selected == "sphere" then
            local obj = self.objects.sphere
            local manipulated, delta = imgui_gizmo.manipulate(
                self.view,
                self.projection,
                operation,
                self.gizmo_mode,
                obj.matrix,
                self.use_snap and self.snap or nil
            )
            if manipulated then
                apply_matrix_to_go(obj.id, obj.matrix)
            end
        elseif self.selected == "cube" then
            local obj = self.objects.cube
            local manipulated, delta = imgui_gizmo.manipulate(
                self.view,
                self.projection,
                operation,
                self.gizmo_mode,
                obj.matrix,
                self.use_snap and self.snap or nil
            )
            if manipulated then
                apply_matrix_to_go(obj.id, obj.matrix)
            end
        end
    end


    local view_matrix = self.view
    local gizmo_size = 120
    local padding = 12
    local pos = vmath.vector3(self.display_width - gizmo_size - padding, padding, 0)
    local size = vmath.vector3(gizmo_size, gizmo_size, 0)
    imgui_gizmo.set_drawlist_foreground()
    imgui_gizmo.view_manipulate(view_matrix, 5, pos, size, 0x101010FF)
    self.view = view_matrix
    local cam_matrix = vmath.inv(view_matrix)
    local cam_pos = imgui_gizmo.decompose_matrix(cam_matrix)
    local cam_rot = imgui_gizmo.quat_look_at(cam_pos, vmath.vector3(0, 0, 0), vmath.vector3(0, 1, 0))
    go.set_position(cam_pos, self.camera_go)
    go.set_rotation(cam_rot, self.camera_go)
end
